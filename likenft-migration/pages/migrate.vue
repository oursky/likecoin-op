<template>
  <div
    class="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]"
  >
    <main class="flex flex-col gap-8 row-start-2 items-center sm:items-start">
      <primary-button @click="handleConnectCosmosWalletClick">
        {{ $t('migrate.connect-cosmos-wallet') }}
      </primary-button>
      <p>{{ $t('migrate.cosmos-wallet-address', { cosmosWalletAddress }) }}</p>
      <p>{{ $t('migrate.liker-id', { likerID }) }}</p>
      <primary-button
        v-if="!isEthAddressMigrated"
        @click="handleConnectEVMWalletClick"
      >
        {{ $t('migrate.connect-evm-wallet') }}
      </primary-button>
      <p>{{ $t('migrate.evm-wallet-address', { evmWalletAddress }) }}</p>
      <primary-button
        v-if="
          !isEthAddressMigrated &&
          cosmosWalletAddress != null &&
          evmWalletAddress != null
        "
        @click="handleMigrateLikerIDClick"
      >
        {{ $t('migrate.migrate-likerid') }}
      </primary-button>
      <div
        v-if="
          migration &&
          (migration.classes.length > 0 || migration.nfts.length > 0)
        "
        class="w-full"
      >
        <div class="max-h-40 overflow-auto">
          <div v-if="migration.classes.length > 0">
            <h5>{{ $t('migrate.classes') }}</h5>
            <ol class="list-decimal pl-10">
              <li v-for="c in migration.classes" :key="c.id">
                <a :href="c.likerland_url">{{ c.name }}</a>
              </li>
            </ol>
          </div>
          <div v-if="migration.nfts.length > 0">
            <h5>{{ $t('migrate.nfts') }}</h5>
            <ol class="list-decimal pl-10">
              <li v-for="n in migration.nfts" :key="n.class_id + '/' + n.id">
                <a :href="n.likerland_url">{{ n.name }}({{ n.id }})</a>
              </li>
            </ol>
          </div>
        </div>
        <primary-button
          v-if="migration.status === 'preview'"
          class="mt-8"
          @click="handleMigrateAssetsClick"
          >{{ $t('migrate.migrate-assets') }}</primary-button
        >
      </div>
    </main>
    <div
      v-if="isLoading"
      class="fixed top-0 left-0 w-full h-full bg-white/90 flex items-center justify-center"
    >
      Loading
    </div>
  </div>
</template>

<script lang="ts">
import {
  LikeCoinWalletConnector,
  LikeCoinWalletConnectorMethodType,
  LikeCoinWalletConnectorSession,
} from '@likecoin/wallet-connector';
import { Eip1193Provider } from 'ethers';
import Vue from 'vue';
import Web3 from 'web3';
import { z } from 'zod';

import { makeCreateMigrationAPI } from '~/apis/createMigration';
import { makeGetMigrationAPI } from '~/apis/getMigration';
import { getSignMessage } from '~/apis/getSignMessage';
import { makeGetUserProfileAPI } from '~/apis/getUserProfile';
import { makeMigrateLikerIDAPI } from '~/apis/migrateLikerID';
import { Migration } from '~/apis/models/migration';
import { LIKECOIN_WALLET_CONNECTOR_CONFIG } from '~/constant/network';

async function getEthereumAccount(
  ethereum: Eip1193Provider
): Promise<string | null> {
  const web3 = new Web3(ethereum);
  await ethereum.request({ method: 'eth_requestAccounts' });
  const accounts = await web3.eth.getAccounts();
  if (accounts.length > 0) {
    return accounts[0];
  }
  return null;
}

async function signEthereumMessage(
  message: string,
  ethereum: Eip1193Provider,
  ethereumAddress: string
) {
  const web3 = new Web3(ethereum);
  const sign = await web3.eth.personal.sign(
    message,
    ethereumAddress,
    'Password!'
  );

  return sign;
}

interface Data {
  cosmosWalletAddress: string | null;
  likerID: string | null;
  evmWalletAddress: string | null;
  isEthAddressMigrated: boolean;
  migration: Migration | null;
  isLoading: boolean;
}

export default Vue.extend({
  data(): Data {
    return {
      cosmosWalletAddress: null,
      likerID: null,
      evmWalletAddress: null,
      isEthAddressMigrated: false,
      migration: null,
      isLoading: false,
    };
  },

  computed: {
    connector() {
      return new LikeCoinWalletConnector(
        LIKECOIN_WALLET_CONNECTOR_CONFIG(this.$appConfig.isTestnet)
      );
    },
    getSignMessage() {
      return getSignMessage(this.$apiClient);
    },
    migrateLikerID() {
      return makeMigrateLikerIDAPI(this.$apiClient);
    },
  },

  methods: {
    async handleConnectCosmosWalletClick() {
      const connection =
        await this.connector?.openConnectionMethodSelectionDialog({});
      this.handleConnection(connection);
    },

    async handleConnection(
      connection: LikeCoinWalletConnectorSession | undefined
    ) {
      if (!connection) return;
      const {
        accounts: [account],
      } = connection;
      this.cosmosWalletAddress = account.address;

      if (this.cosmosWalletAddress != null) {
        this.isLoading = true;
        try {
          const userProfile = await makeGetUserProfileAPI(
            this.cosmosWalletAddress
          )(this.$apiClient)();
          this.likerID = userProfile.user_profile.liker_id;
          this.evmWalletAddress = userProfile.user_profile.eth_wallet_address;
          this.isEthAddressMigrated = this.evmWalletAddress != null;
          if (this.isEthAddressMigrated) {
            await this.fetchMigration(this.cosmosWalletAddress);
          }
        } finally {
          this.isLoading = false;
        }
      }

      this.connector?.once('account_change', this.handleAccountChange);
    },

    async handleAccountChange(method: LikeCoinWalletConnectorMethodType) {
      const connection = await this.connector?.init(method);
      this.handleConnection(connection);
    },

    async handleConnectEVMWalletClick() {
      this.isLoading = true;
      if (window.ethereum == null) {
        alert('Please install metamask extension');
        return;
      }
      try {
        this.evmWalletAddress = await getEthereumAccount(window.ethereum);
        if (this.cosmosWalletAddress != null) {
          await this.fetchMigration(this.cosmosWalletAddress);
        }
      } catch (e) {
        console.error(e);
      } finally {
        this.isLoading = false;
      }
    },

    async handleMigrateLikerIDClick() {
      const S = z.object({
        cosmosWalletAddress: z.string(),
        evmWalletAddress: z.string(),
      });
      const s = S.safeParse({
        cosmosWalletAddress: this.cosmosWalletAddress,
        evmWalletAddress: this.evmWalletAddress,
      });
      if (s.data == null) {
        return;
      }
      if (window.ethereum == null) {
        alert('Please install metamask extension');
        return;
      }
      if (!this.isEthAddressMigrated) {
        const signMessage = await this.getSignMessage({
          cosmos_address: s.data.cosmosWalletAddress,
          eth_address: s.data.evmWalletAddress,
          liker_id: this.likerID,
        });
        const connection = await this.connector.initIfNecessary();
        if (connection == null) {
          alert('cannot get wallet connector connection');
          return;
        }
        const {
          accounts: [account],
          offlineSigner,
        } = connection;

        if (!offlineSigner.signArbitrary) {
          alert('signArbitrary not supported');
          return;
        }
        const result = await offlineSigner.signArbitrary(
          this.connector.options.chainId,
          account.address,
          signMessage.message
        );
        const cosmosSignature = result.signature;
        const signedMessage = await signEthereumMessage(
          signMessage.message,
          window.ethereum,
          s.data.evmWalletAddress
        );

        await this.migrateLikerID({
          cosmos_pub_key: result.pub_key.value,
          cosmos_signature: cosmosSignature,
          eth_address: s.data.evmWalletAddress,
          eth_signature: signedMessage,
          like_id: this.likerID,
          signing_message: signMessage.message,
        });
      }
    },

    async fetchMigration(cosmosWalletAddress: string) {
      const migrationResponse = await makeGetMigrationAPI(cosmosWalletAddress)(
        this.$apiClient
      )();
      this.migration = migrationResponse.migration;
    },

    async handleMigrateAssetsClick() {
      if (this.evmWalletAddress == null || this.cosmosWalletAddress == null) {
        return;
      }
      this.isLoading = true;
      try {
        const createMigrationResponse = await makeCreateMigrationAPI(
          this.$apiClient
        )({
          cosmos_address: this.cosmosWalletAddress,
          eth_address: this.evmWalletAddress,
        });
        this.migration = createMigrationResponse.migration;
      } finally {
        this.isLoading = false;
      }
    },
  },
});
</script>
