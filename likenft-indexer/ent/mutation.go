// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"likenft-indexer/ent/account"
	"likenft-indexer/ent/evmevent"
	"likenft-indexer/ent/nft"
	"likenft-indexer/ent/nftclass"
	"likenft-indexer/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount  = "Account"
	TypeEVMEvent = "EVMEvent"
	TypeNFT      = "NFT"
	TypeNFTClass = "NFTClass"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	cosmos_address     *string
	evm_address        *string
	likeid             *string
	clearedFields      map[string]struct{}
	nft_classes        map[int]struct{}
	removednft_classes map[int]struct{}
	clearednft_classes bool
	nfts               map[int]struct{}
	removednfts        map[int]struct{}
	clearednfts        bool
	done               bool
	oldValue           func(context.Context) (*Account, error)
	predicates         []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCosmosAddress sets the "cosmos_address" field.
func (m *AccountMutation) SetCosmosAddress(s string) {
	m.cosmos_address = &s
}

// CosmosAddress returns the value of the "cosmos_address" field in the mutation.
func (m *AccountMutation) CosmosAddress() (r string, exists bool) {
	v := m.cosmos_address
	if v == nil {
		return
	}
	return *v, true
}

// OldCosmosAddress returns the old "cosmos_address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCosmosAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCosmosAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCosmosAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCosmosAddress: %w", err)
	}
	return oldValue.CosmosAddress, nil
}

// ClearCosmosAddress clears the value of the "cosmos_address" field.
func (m *AccountMutation) ClearCosmosAddress() {
	m.cosmos_address = nil
	m.clearedFields[account.FieldCosmosAddress] = struct{}{}
}

// CosmosAddressCleared returns if the "cosmos_address" field was cleared in this mutation.
func (m *AccountMutation) CosmosAddressCleared() bool {
	_, ok := m.clearedFields[account.FieldCosmosAddress]
	return ok
}

// ResetCosmosAddress resets all changes to the "cosmos_address" field.
func (m *AccountMutation) ResetCosmosAddress() {
	m.cosmos_address = nil
	delete(m.clearedFields, account.FieldCosmosAddress)
}

// SetEvmAddress sets the "evm_address" field.
func (m *AccountMutation) SetEvmAddress(s string) {
	m.evm_address = &s
}

// EvmAddress returns the value of the "evm_address" field in the mutation.
func (m *AccountMutation) EvmAddress() (r string, exists bool) {
	v := m.evm_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEvmAddress returns the old "evm_address" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEvmAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvmAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvmAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvmAddress: %w", err)
	}
	return oldValue.EvmAddress, nil
}

// ResetEvmAddress resets all changes to the "evm_address" field.
func (m *AccountMutation) ResetEvmAddress() {
	m.evm_address = nil
}

// SetLikeid sets the "likeid" field.
func (m *AccountMutation) SetLikeid(s string) {
	m.likeid = &s
}

// Likeid returns the value of the "likeid" field in the mutation.
func (m *AccountMutation) Likeid() (r string, exists bool) {
	v := m.likeid
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeid returns the old "likeid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLikeid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeid: %w", err)
	}
	return oldValue.Likeid, nil
}

// ClearLikeid clears the value of the "likeid" field.
func (m *AccountMutation) ClearLikeid() {
	m.likeid = nil
	m.clearedFields[account.FieldLikeid] = struct{}{}
}

// LikeidCleared returns if the "likeid" field was cleared in this mutation.
func (m *AccountMutation) LikeidCleared() bool {
	_, ok := m.clearedFields[account.FieldLikeid]
	return ok
}

// ResetLikeid resets all changes to the "likeid" field.
func (m *AccountMutation) ResetLikeid() {
	m.likeid = nil
	delete(m.clearedFields, account.FieldLikeid)
}

// AddNftClassIDs adds the "nft_classes" edge to the NFTClass entity by ids.
func (m *AccountMutation) AddNftClassIDs(ids ...int) {
	if m.nft_classes == nil {
		m.nft_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.nft_classes[ids[i]] = struct{}{}
	}
}

// ClearNftClasses clears the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) ClearNftClasses() {
	m.clearednft_classes = true
}

// NftClassesCleared reports if the "nft_classes" edge to the NFTClass entity was cleared.
func (m *AccountMutation) NftClassesCleared() bool {
	return m.clearednft_classes
}

// RemoveNftClassIDs removes the "nft_classes" edge to the NFTClass entity by IDs.
func (m *AccountMutation) RemoveNftClassIDs(ids ...int) {
	if m.removednft_classes == nil {
		m.removednft_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nft_classes, ids[i])
		m.removednft_classes[ids[i]] = struct{}{}
	}
}

// RemovedNftClasses returns the removed IDs of the "nft_classes" edge to the NFTClass entity.
func (m *AccountMutation) RemovedNftClassesIDs() (ids []int) {
	for id := range m.removednft_classes {
		ids = append(ids, id)
	}
	return
}

// NftClassesIDs returns the "nft_classes" edge IDs in the mutation.
func (m *AccountMutation) NftClassesIDs() (ids []int) {
	for id := range m.nft_classes {
		ids = append(ids, id)
	}
	return
}

// ResetNftClasses resets all changes to the "nft_classes" edge.
func (m *AccountMutation) ResetNftClasses() {
	m.nft_classes = nil
	m.clearednft_classes = false
	m.removednft_classes = nil
}

// AddNftIDs adds the "nfts" edge to the NFT entity by ids.
func (m *AccountMutation) AddNftIDs(ids ...int) {
	if m.nfts == nil {
		m.nfts = make(map[int]struct{})
	}
	for i := range ids {
		m.nfts[ids[i]] = struct{}{}
	}
}

// ClearNfts clears the "nfts" edge to the NFT entity.
func (m *AccountMutation) ClearNfts() {
	m.clearednfts = true
}

// NftsCleared reports if the "nfts" edge to the NFT entity was cleared.
func (m *AccountMutation) NftsCleared() bool {
	return m.clearednfts
}

// RemoveNftIDs removes the "nfts" edge to the NFT entity by IDs.
func (m *AccountMutation) RemoveNftIDs(ids ...int) {
	if m.removednfts == nil {
		m.removednfts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nfts, ids[i])
		m.removednfts[ids[i]] = struct{}{}
	}
}

// RemovedNfts returns the removed IDs of the "nfts" edge to the NFT entity.
func (m *AccountMutation) RemovedNftsIDs() (ids []int) {
	for id := range m.removednfts {
		ids = append(ids, id)
	}
	return
}

// NftsIDs returns the "nfts" edge IDs in the mutation.
func (m *AccountMutation) NftsIDs() (ids []int) {
	for id := range m.nfts {
		ids = append(ids, id)
	}
	return
}

// ResetNfts resets all changes to the "nfts" edge.
func (m *AccountMutation) ResetNfts() {
	m.nfts = nil
	m.clearednfts = false
	m.removednfts = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.cosmos_address != nil {
		fields = append(fields, account.FieldCosmosAddress)
	}
	if m.evm_address != nil {
		fields = append(fields, account.FieldEvmAddress)
	}
	if m.likeid != nil {
		fields = append(fields, account.FieldLikeid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCosmosAddress:
		return m.CosmosAddress()
	case account.FieldEvmAddress:
		return m.EvmAddress()
	case account.FieldLikeid:
		return m.Likeid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCosmosAddress:
		return m.OldCosmosAddress(ctx)
	case account.FieldEvmAddress:
		return m.OldEvmAddress(ctx)
	case account.FieldLikeid:
		return m.OldLikeid(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCosmosAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCosmosAddress(v)
		return nil
	case account.FieldEvmAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvmAddress(v)
		return nil
	case account.FieldLikeid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeid(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldCosmosAddress) {
		fields = append(fields, account.FieldCosmosAddress)
	}
	if m.FieldCleared(account.FieldLikeid) {
		fields = append(fields, account.FieldLikeid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldCosmosAddress:
		m.ClearCosmosAddress()
		return nil
	case account.FieldLikeid:
		m.ClearLikeid()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCosmosAddress:
		m.ResetCosmosAddress()
		return nil
	case account.FieldEvmAddress:
		m.ResetEvmAddress()
		return nil
	case account.FieldLikeid:
		m.ResetLikeid()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.nfts != nil {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.nft_classes))
		for id := range m.nft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.nfts))
		for id := range m.nfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednft_classes != nil {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.removednfts != nil {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeNftClasses:
		ids := make([]ent.Value, 0, len(m.removednft_classes))
		for id := range m.removednft_classes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.removednfts))
		for id := range m.removednfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednft_classes {
		edges = append(edges, account.EdgeNftClasses)
	}
	if m.clearednfts {
		edges = append(edges, account.EdgeNfts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeNftClasses:
		return m.clearednft_classes
	case account.EdgeNfts:
		return m.clearednfts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeNftClasses:
		m.ResetNftClasses()
		return nil
	case account.EdgeNfts:
		m.ResetNfts()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// EVMEventMutation represents an operation that mutates the EVMEvent nodes in the graph.
type EVMEventMutation struct {
	config
	op               Op
	typ              string
	id               *int
	transaction_hash *string
	block_hash       *string
	block_number     *uint64
	addblock_number  *int64
	log_index        *uint64
	addlog_index     *int64
	address          *string
	topic0           *string
	topic1           *string
	topic2           *string
	topic3           *string
	data             *string
	timestamp        *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EVMEvent, error)
	predicates       []predicate.EVMEvent
}

var _ ent.Mutation = (*EVMEventMutation)(nil)

// evmeventOption allows management of the mutation configuration using functional options.
type evmeventOption func(*EVMEventMutation)

// newEVMEventMutation creates new mutation for the EVMEvent entity.
func newEVMEventMutation(c config, op Op, opts ...evmeventOption) *EVMEventMutation {
	m := &EVMEventMutation{
		config:        c,
		op:            op,
		typ:           TypeEVMEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEVMEventID sets the ID field of the mutation.
func withEVMEventID(id int) evmeventOption {
	return func(m *EVMEventMutation) {
		var (
			err   error
			once  sync.Once
			value *EVMEvent
		)
		m.oldValue = func(ctx context.Context) (*EVMEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EVMEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEVMEvent sets the old EVMEvent of the mutation.
func withEVMEvent(node *EVMEvent) evmeventOption {
	return func(m *EVMEventMutation) {
		m.oldValue = func(context.Context) (*EVMEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EVMEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EVMEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EVMEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EVMEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EVMEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *EVMEventMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *EVMEventMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *EVMEventMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetBlockHash sets the "block_hash" field.
func (m *EVMEventMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *EVMEventMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *EVMEventMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *EVMEventMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *EVMEventMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *EVMEventMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *EVMEventMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *EVMEventMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetLogIndex sets the "log_index" field.
func (m *EVMEventMutation) SetLogIndex(u uint64) {
	m.log_index = &u
	m.addlog_index = nil
}

// LogIndex returns the value of the "log_index" field in the mutation.
func (m *EVMEventMutation) LogIndex() (r uint64, exists bool) {
	v := m.log_index
	if v == nil {
		return
	}
	return *v, true
}

// OldLogIndex returns the old "log_index" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldLogIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogIndex: %w", err)
	}
	return oldValue.LogIndex, nil
}

// AddLogIndex adds u to the "log_index" field.
func (m *EVMEventMutation) AddLogIndex(u int64) {
	if m.addlog_index != nil {
		*m.addlog_index += u
	} else {
		m.addlog_index = &u
	}
}

// AddedLogIndex returns the value that was added to the "log_index" field in this mutation.
func (m *EVMEventMutation) AddedLogIndex() (r int64, exists bool) {
	v := m.addlog_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetLogIndex resets all changes to the "log_index" field.
func (m *EVMEventMutation) ResetLogIndex() {
	m.log_index = nil
	m.addlog_index = nil
}

// SetAddress sets the "address" field.
func (m *EVMEventMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EVMEventMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EVMEventMutation) ResetAddress() {
	m.address = nil
}

// SetTopic0 sets the "topic0" field.
func (m *EVMEventMutation) SetTopic0(s string) {
	m.topic0 = &s
}

// Topic0 returns the value of the "topic0" field in the mutation.
func (m *EVMEventMutation) Topic0() (r string, exists bool) {
	v := m.topic0
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic0 returns the old "topic0" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic0(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic0: %w", err)
	}
	return oldValue.Topic0, nil
}

// ResetTopic0 resets all changes to the "topic0" field.
func (m *EVMEventMutation) ResetTopic0() {
	m.topic0 = nil
}

// SetTopic1 sets the "topic1" field.
func (m *EVMEventMutation) SetTopic1(s string) {
	m.topic1 = &s
}

// Topic1 returns the value of the "topic1" field in the mutation.
func (m *EVMEventMutation) Topic1() (r string, exists bool) {
	v := m.topic1
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic1 returns the old "topic1" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic1: %w", err)
	}
	return oldValue.Topic1, nil
}

// ResetTopic1 resets all changes to the "topic1" field.
func (m *EVMEventMutation) ResetTopic1() {
	m.topic1 = nil
}

// SetTopic2 sets the "topic2" field.
func (m *EVMEventMutation) SetTopic2(s string) {
	m.topic2 = &s
}

// Topic2 returns the value of the "topic2" field in the mutation.
func (m *EVMEventMutation) Topic2() (r string, exists bool) {
	v := m.topic2
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic2 returns the old "topic2" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic2: %w", err)
	}
	return oldValue.Topic2, nil
}

// ResetTopic2 resets all changes to the "topic2" field.
func (m *EVMEventMutation) ResetTopic2() {
	m.topic2 = nil
}

// SetTopic3 sets the "topic3" field.
func (m *EVMEventMutation) SetTopic3(s string) {
	m.topic3 = &s
}

// Topic3 returns the value of the "topic3" field in the mutation.
func (m *EVMEventMutation) Topic3() (r string, exists bool) {
	v := m.topic3
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic3 returns the old "topic3" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTopic3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic3: %w", err)
	}
	return oldValue.Topic3, nil
}

// ResetTopic3 resets all changes to the "topic3" field.
func (m *EVMEventMutation) ResetTopic3() {
	m.topic3 = nil
}

// SetData sets the "data" field.
func (m *EVMEventMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *EVMEventMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *EVMEventMutation) ResetData() {
	m.data = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *EVMEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EVMEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the EVMEvent entity.
// If the EVMEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EVMEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EVMEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// Where appends a list predicates to the EVMEventMutation builder.
func (m *EVMEventMutation) Where(ps ...predicate.EVMEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EVMEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EVMEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EVMEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EVMEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EVMEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EVMEvent).
func (m *EVMEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EVMEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.transaction_hash != nil {
		fields = append(fields, evmevent.FieldTransactionHash)
	}
	if m.block_hash != nil {
		fields = append(fields, evmevent.FieldBlockHash)
	}
	if m.block_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.log_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	if m.address != nil {
		fields = append(fields, evmevent.FieldAddress)
	}
	if m.topic0 != nil {
		fields = append(fields, evmevent.FieldTopic0)
	}
	if m.topic1 != nil {
		fields = append(fields, evmevent.FieldTopic1)
	}
	if m.topic2 != nil {
		fields = append(fields, evmevent.FieldTopic2)
	}
	if m.topic3 != nil {
		fields = append(fields, evmevent.FieldTopic3)
	}
	if m.data != nil {
		fields = append(fields, evmevent.FieldData)
	}
	if m.timestamp != nil {
		fields = append(fields, evmevent.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EVMEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.TransactionHash()
	case evmevent.FieldBlockHash:
		return m.BlockHash()
	case evmevent.FieldBlockNumber:
		return m.BlockNumber()
	case evmevent.FieldLogIndex:
		return m.LogIndex()
	case evmevent.FieldAddress:
		return m.Address()
	case evmevent.FieldTopic0:
		return m.Topic0()
	case evmevent.FieldTopic1:
		return m.Topic1()
	case evmevent.FieldTopic2:
		return m.Topic2()
	case evmevent.FieldTopic3:
		return m.Topic3()
	case evmevent.FieldData:
		return m.Data()
	case evmevent.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EVMEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evmevent.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case evmevent.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case evmevent.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case evmevent.FieldLogIndex:
		return m.OldLogIndex(ctx)
	case evmevent.FieldAddress:
		return m.OldAddress(ctx)
	case evmevent.FieldTopic0:
		return m.OldTopic0(ctx)
	case evmevent.FieldTopic1:
		return m.OldTopic1(ctx)
	case evmevent.FieldTopic2:
		return m.OldTopic2(ctx)
	case evmevent.FieldTopic3:
		return m.OldTopic3(ctx)
	case evmevent.FieldData:
		return m.OldData(ctx)
	case evmevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown EVMEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case evmevent.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case evmevent.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogIndex(v)
		return nil
	case evmevent.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case evmevent.FieldTopic0:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic0(v)
		return nil
	case evmevent.FieldTopic1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic1(v)
		return nil
	case evmevent.FieldTopic2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic2(v)
		return nil
	case evmevent.FieldTopic3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic3(v)
		return nil
	case evmevent.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case evmevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EVMEventMutation) AddedFields() []string {
	var fields []string
	if m.addblock_number != nil {
		fields = append(fields, evmevent.FieldBlockNumber)
	}
	if m.addlog_index != nil {
		fields = append(fields, evmevent.FieldLogIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EVMEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evmevent.FieldBlockNumber:
		return m.AddedBlockNumber()
	case evmevent.FieldLogIndex:
		return m.AddedLogIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EVMEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evmevent.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case evmevent.FieldLogIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogIndex(v)
		return nil
	}
	return fmt.Errorf("unknown EVMEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EVMEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EVMEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EVMEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EVMEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EVMEventMutation) ResetField(name string) error {
	switch name {
	case evmevent.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case evmevent.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case evmevent.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case evmevent.FieldLogIndex:
		m.ResetLogIndex()
		return nil
	case evmevent.FieldAddress:
		m.ResetAddress()
		return nil
	case evmevent.FieldTopic0:
		m.ResetTopic0()
		return nil
	case evmevent.FieldTopic1:
		m.ResetTopic1()
		return nil
	case evmevent.FieldTopic2:
		m.ResetTopic2()
		return nil
	case evmevent.FieldTopic3:
		m.ResetTopic3()
		return nil
	case evmevent.FieldData:
		m.ResetData()
		return nil
	case evmevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown EVMEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EVMEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EVMEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EVMEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EVMEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EVMEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EVMEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EVMEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EVMEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EVMEvent edge %s", name)
}

// NFTMutation represents an operation that mutates the NFT nodes in the graph.
type NFTMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token_id      *uint64
	addtoken_id   *int64
	token_url     *string
	raw           *map[string]interface{}
	name          *string
	description   *string
	image         *map[string]interface{}
	attributes    *map[string]interface{}
	owner_address *string
	minted_at     *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	class         *int
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*NFT, error)
	predicates    []predicate.NFT
}

var _ ent.Mutation = (*NFTMutation)(nil)

// nftOption allows management of the mutation configuration using functional options.
type nftOption func(*NFTMutation)

// newNFTMutation creates new mutation for the NFT entity.
func newNFTMutation(c config, op Op, opts ...nftOption) *NFTMutation {
	m := &NFTMutation{
		config:        c,
		op:            op,
		typ:           TypeNFT,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTID sets the ID field of the mutation.
func withNFTID(id int) nftOption {
	return func(m *NFTMutation) {
		var (
			err   error
			once  sync.Once
			value *NFT
		)
		m.oldValue = func(ctx context.Context) (*NFT, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFT.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFT sets the old NFT of the mutation.
func withNFT(node *NFT) nftOption {
	return func(m *NFTMutation) {
		m.oldValue = func(context.Context) (*NFT, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFT.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTokenID sets the "token_id" field.
func (m *NFTMutation) SetTokenID(u uint64) {
	m.token_id = &u
	m.addtoken_id = nil
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *NFTMutation) TokenID() (r uint64, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldTokenID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// AddTokenID adds u to the "token_id" field.
func (m *NFTMutation) AddTokenID(u int64) {
	if m.addtoken_id != nil {
		*m.addtoken_id += u
	} else {
		m.addtoken_id = &u
	}
}

// AddedTokenID returns the value that was added to the "token_id" field in this mutation.
func (m *NFTMutation) AddedTokenID() (r int64, exists bool) {
	v := m.addtoken_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *NFTMutation) ResetTokenID() {
	m.token_id = nil
	m.addtoken_id = nil
}

// SetTokenURL sets the "token_url" field.
func (m *NFTMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *NFTMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ClearTokenURL clears the value of the "token_url" field.
func (m *NFTMutation) ClearTokenURL() {
	m.token_url = nil
	m.clearedFields[nft.FieldTokenURL] = struct{}{}
}

// TokenURLCleared returns if the "token_url" field was cleared in this mutation.
func (m *NFTMutation) TokenURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldTokenURL]
	return ok
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *NFTMutation) ResetTokenURL() {
	m.token_url = nil
	delete(m.clearedFields, nft.FieldTokenURL)
}

// SetRaw sets the "raw" field.
func (m *NFTMutation) SetRaw(value map[string]interface{}) {
	m.raw = &value
}

// Raw returns the value of the "raw" field in the mutation.
func (m *NFTMutation) Raw() (r map[string]interface{}, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldRaw(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *NFTMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[nft.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *NFTMutation) RawCleared() bool {
	_, ok := m.clearedFields[nft.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *NFTMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, nft.FieldRaw)
}

// SetName sets the "name" field.
func (m *NFTMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NFTMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NFTMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NFTMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NFTMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NFTMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[nft.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NFTMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[nft.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NFTMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, nft.FieldDescription)
}

// SetImage sets the "image" field.
func (m *NFTMutation) SetImage(value map[string]interface{}) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *NFTMutation) Image() (r map[string]interface{}, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldImage(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *NFTMutation) ClearImage() {
	m.image = nil
	m.clearedFields[nft.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *NFTMutation) ImageCleared() bool {
	_, ok := m.clearedFields[nft.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *NFTMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, nft.FieldImage)
}

// SetAttributes sets the "attributes" field.
func (m *NFTMutation) SetAttributes(value map[string]interface{}) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *NFTMutation) Attributes() (r map[string]interface{}, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldAttributes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *NFTMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[nft.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *NFTMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[nft.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *NFTMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, nft.FieldAttributes)
}

// SetOwnerAddress sets the "owner_address" field.
func (m *NFTMutation) SetOwnerAddress(s string) {
	m.owner_address = &s
}

// OwnerAddress returns the value of the "owner_address" field in the mutation.
func (m *NFTMutation) OwnerAddress() (r string, exists bool) {
	v := m.owner_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "owner_address" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldOwnerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ResetOwnerAddress resets all changes to the "owner_address" field.
func (m *NFTMutation) ResetOwnerAddress() {
	m.owner_address = nil
}

// SetMintedAt sets the "minted_at" field.
func (m *NFTMutation) SetMintedAt(t time.Time) {
	m.minted_at = &t
}

// MintedAt returns the value of the "minted_at" field in the mutation.
func (m *NFTMutation) MintedAt() (r time.Time, exists bool) {
	v := m.minted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMintedAt returns the old "minted_at" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMintedAt: %w", err)
	}
	return oldValue.MintedAt, nil
}

// ResetMintedAt resets all changes to the "minted_at" field.
func (m *NFTMutation) ResetMintedAt() {
	m.minted_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NFTMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NFTMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NFTMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NFTMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NFTMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NFTMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NFTMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NFTMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NFTMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetClassID sets the "class" edge to the NFTClass entity by id.
func (m *NFTMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the NFTClass entity.
func (m *NFTMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the NFTClass entity was cleared.
func (m *NFTMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *NFTMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *NFTMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *NFTMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the NFTMutation builder.
func (m *NFTMutation) Where(ps ...predicate.NFT) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NFTMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NFTMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NFT, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NFTMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NFTMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NFT).
func (m *NFTMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.token_id != nil {
		fields = append(fields, nft.FieldTokenID)
	}
	if m.token_url != nil {
		fields = append(fields, nft.FieldTokenURL)
	}
	if m.raw != nil {
		fields = append(fields, nft.FieldRaw)
	}
	if m.name != nil {
		fields = append(fields, nft.FieldName)
	}
	if m.description != nil {
		fields = append(fields, nft.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, nft.FieldImage)
	}
	if m.attributes != nil {
		fields = append(fields, nft.FieldAttributes)
	}
	if m.owner_address != nil {
		fields = append(fields, nft.FieldOwnerAddress)
	}
	if m.minted_at != nil {
		fields = append(fields, nft.FieldMintedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nft.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldTokenID:
		return m.TokenID()
	case nft.FieldTokenURL:
		return m.TokenURL()
	case nft.FieldRaw:
		return m.Raw()
	case nft.FieldName:
		return m.Name()
	case nft.FieldDescription:
		return m.Description()
	case nft.FieldImage:
		return m.Image()
	case nft.FieldAttributes:
		return m.Attributes()
	case nft.FieldOwnerAddress:
		return m.OwnerAddress()
	case nft.FieldMintedAt:
		return m.MintedAt()
	case nft.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nft.FieldTokenID:
		return m.OldTokenID(ctx)
	case nft.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case nft.FieldRaw:
		return m.OldRaw(ctx)
	case nft.FieldName:
		return m.OldName(ctx)
	case nft.FieldDescription:
		return m.OldDescription(ctx)
	case nft.FieldImage:
		return m.OldImage(ctx)
	case nft.FieldAttributes:
		return m.OldAttributes(ctx)
	case nft.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case nft.FieldMintedAt:
		return m.OldMintedAt(ctx)
	case nft.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NFT field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nft.FieldTokenID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case nft.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case nft.FieldRaw:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	case nft.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nft.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case nft.FieldImage:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case nft.FieldAttributes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case nft.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case nft.FieldMintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMintedAt(v)
		return nil
	case nft.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_id != nil {
		fields = append(fields, nft.FieldTokenID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldTokenID:
		return m.AddedTokenID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nft.FieldTokenID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenID(v)
		return nil
	}
	return fmt.Errorf("unknown NFT numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nft.FieldTokenURL) {
		fields = append(fields, nft.FieldTokenURL)
	}
	if m.FieldCleared(nft.FieldRaw) {
		fields = append(fields, nft.FieldRaw)
	}
	if m.FieldCleared(nft.FieldDescription) {
		fields = append(fields, nft.FieldDescription)
	}
	if m.FieldCleared(nft.FieldImage) {
		fields = append(fields, nft.FieldImage)
	}
	if m.FieldCleared(nft.FieldAttributes) {
		fields = append(fields, nft.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTMutation) ClearField(name string) error {
	switch name {
	case nft.FieldTokenURL:
		m.ClearTokenURL()
		return nil
	case nft.FieldRaw:
		m.ClearRaw()
		return nil
	case nft.FieldDescription:
		m.ClearDescription()
		return nil
	case nft.FieldImage:
		m.ClearImage()
		return nil
	case nft.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown NFT nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTMutation) ResetField(name string) error {
	switch name {
	case nft.FieldTokenID:
		m.ResetTokenID()
		return nil
	case nft.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case nft.FieldRaw:
		m.ResetRaw()
		return nil
	case nft.FieldName:
		m.ResetName()
		return nil
	case nft.FieldDescription:
		m.ResetDescription()
		return nil
	case nft.FieldImage:
		m.ResetImage()
		return nil
	case nft.FieldAttributes:
		m.ResetAttributes()
		return nil
	case nft.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case nft.FieldMintedAt:
		m.ResetMintedAt()
		return nil
	case nft.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, nft.EdgeOwner)
	}
	if m.class != nil {
		edges = append(edges, nft.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nft.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case nft.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, nft.EdgeOwner)
	}
	if m.clearedclass {
		edges = append(edges, nft.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTMutation) EdgeCleared(name string) bool {
	switch name {
	case nft.EdgeOwner:
		return m.clearedowner
	case nft.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTMutation) ClearEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ClearOwner()
		return nil
	case nft.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown NFT unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTMutation) ResetEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ResetOwner()
		return nil
	case nft.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown NFT edge %s", name)
}

// NFTClassMutation represents an operation that mutates the NFTClass nodes in the graph.
type NFTClassMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	address                *string
	name                   *string
	symbol                 *string
	owner_address          *string
	minter_addresses       *[]string
	appendminter_addresses []string
	total_supply           *int
	addtotal_supply        *int
	metadata               *map[string]interface{}
	banner_image           *string
	featured_image         *string
	deployer_address       *string
	deployed_block_number  *string
	minted_at              *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	nfts                   map[int]struct{}
	removednfts            map[int]struct{}
	clearednfts            bool
	owner                  *int
	clearedowner           bool
	done                   bool
	oldValue               func(context.Context) (*NFTClass, error)
	predicates             []predicate.NFTClass
}

var _ ent.Mutation = (*NFTClassMutation)(nil)

// nftclassOption allows management of the mutation configuration using functional options.
type nftclassOption func(*NFTClassMutation)

// newNFTClassMutation creates new mutation for the NFTClass entity.
func newNFTClassMutation(c config, op Op, opts ...nftclassOption) *NFTClassMutation {
	m := &NFTClassMutation{
		config:        c,
		op:            op,
		typ:           TypeNFTClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTClassID sets the ID field of the mutation.
func withNFTClassID(id int) nftclassOption {
	return func(m *NFTClassMutation) {
		var (
			err   error
			once  sync.Once
			value *NFTClass
		)
		m.oldValue = func(ctx context.Context) (*NFTClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFTClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFTClass sets the old NFTClass of the mutation.
func withNFTClass(node *NFTClass) nftclassOption {
	return func(m *NFTClassMutation) {
		m.oldValue = func(context.Context) (*NFTClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFTClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *NFTClassMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *NFTClassMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *NFTClassMutation) ResetAddress() {
	m.address = nil
}

// SetName sets the "name" field.
func (m *NFTClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NFTClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NFTClassMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *NFTClassMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *NFTClassMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *NFTClassMutation) ResetSymbol() {
	m.symbol = nil
}

// SetOwnerAddress sets the "owner_address" field.
func (m *NFTClassMutation) SetOwnerAddress(s string) {
	m.owner_address = &s
}

// OwnerAddress returns the value of the "owner_address" field in the mutation.
func (m *NFTClassMutation) OwnerAddress() (r string, exists bool) {
	v := m.owner_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "owner_address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldOwnerAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ClearOwnerAddress clears the value of the "owner_address" field.
func (m *NFTClassMutation) ClearOwnerAddress() {
	m.owner_address = nil
	m.clearedFields[nftclass.FieldOwnerAddress] = struct{}{}
}

// OwnerAddressCleared returns if the "owner_address" field was cleared in this mutation.
func (m *NFTClassMutation) OwnerAddressCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldOwnerAddress]
	return ok
}

// ResetOwnerAddress resets all changes to the "owner_address" field.
func (m *NFTClassMutation) ResetOwnerAddress() {
	m.owner_address = nil
	delete(m.clearedFields, nftclass.FieldOwnerAddress)
}

// SetMinterAddresses sets the "minter_addresses" field.
func (m *NFTClassMutation) SetMinterAddresses(s []string) {
	m.minter_addresses = &s
	m.appendminter_addresses = nil
}

// MinterAddresses returns the value of the "minter_addresses" field in the mutation.
func (m *NFTClassMutation) MinterAddresses() (r []string, exists bool) {
	v := m.minter_addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldMinterAddresses returns the old "minter_addresses" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMinterAddresses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinterAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinterAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinterAddresses: %w", err)
	}
	return oldValue.MinterAddresses, nil
}

// AppendMinterAddresses adds s to the "minter_addresses" field.
func (m *NFTClassMutation) AppendMinterAddresses(s []string) {
	m.appendminter_addresses = append(m.appendminter_addresses, s...)
}

// AppendedMinterAddresses returns the list of values that were appended to the "minter_addresses" field in this mutation.
func (m *NFTClassMutation) AppendedMinterAddresses() ([]string, bool) {
	if len(m.appendminter_addresses) == 0 {
		return nil, false
	}
	return m.appendminter_addresses, true
}

// ClearMinterAddresses clears the value of the "minter_addresses" field.
func (m *NFTClassMutation) ClearMinterAddresses() {
	m.minter_addresses = nil
	m.appendminter_addresses = nil
	m.clearedFields[nftclass.FieldMinterAddresses] = struct{}{}
}

// MinterAddressesCleared returns if the "minter_addresses" field was cleared in this mutation.
func (m *NFTClassMutation) MinterAddressesCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldMinterAddresses]
	return ok
}

// ResetMinterAddresses resets all changes to the "minter_addresses" field.
func (m *NFTClassMutation) ResetMinterAddresses() {
	m.minter_addresses = nil
	m.appendminter_addresses = nil
	delete(m.clearedFields, nftclass.FieldMinterAddresses)
}

// SetTotalSupply sets the "total_supply" field.
func (m *NFTClassMutation) SetTotalSupply(i int) {
	m.total_supply = &i
	m.addtotal_supply = nil
}

// TotalSupply returns the value of the "total_supply" field in the mutation.
func (m *NFTClassMutation) TotalSupply() (r int, exists bool) {
	v := m.total_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSupply returns the old "total_supply" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldTotalSupply(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSupply: %w", err)
	}
	return oldValue.TotalSupply, nil
}

// AddTotalSupply adds i to the "total_supply" field.
func (m *NFTClassMutation) AddTotalSupply(i int) {
	if m.addtotal_supply != nil {
		*m.addtotal_supply += i
	} else {
		m.addtotal_supply = &i
	}
}

// AddedTotalSupply returns the value that was added to the "total_supply" field in this mutation.
func (m *NFTClassMutation) AddedTotalSupply() (r int, exists bool) {
	v := m.addtotal_supply
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSupply resets all changes to the "total_supply" field.
func (m *NFTClassMutation) ResetTotalSupply() {
	m.total_supply = nil
	m.addtotal_supply = nil
}

// SetMetadata sets the "metadata" field.
func (m *NFTClassMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NFTClassMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NFTClassMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[nftclass.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NFTClassMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[nftclass.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NFTClassMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, nftclass.FieldMetadata)
}

// SetBannerImage sets the "banner_image" field.
func (m *NFTClassMutation) SetBannerImage(s string) {
	m.banner_image = &s
}

// BannerImage returns the value of the "banner_image" field in the mutation.
func (m *NFTClassMutation) BannerImage() (r string, exists bool) {
	v := m.banner_image
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerImage returns the old "banner_image" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldBannerImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerImage: %w", err)
	}
	return oldValue.BannerImage, nil
}

// ResetBannerImage resets all changes to the "banner_image" field.
func (m *NFTClassMutation) ResetBannerImage() {
	m.banner_image = nil
}

// SetFeaturedImage sets the "featured_image" field.
func (m *NFTClassMutation) SetFeaturedImage(s string) {
	m.featured_image = &s
}

// FeaturedImage returns the value of the "featured_image" field in the mutation.
func (m *NFTClassMutation) FeaturedImage() (r string, exists bool) {
	v := m.featured_image
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImage returns the old "featured_image" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldFeaturedImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImage: %w", err)
	}
	return oldValue.FeaturedImage, nil
}

// ResetFeaturedImage resets all changes to the "featured_image" field.
func (m *NFTClassMutation) ResetFeaturedImage() {
	m.featured_image = nil
}

// SetDeployerAddress sets the "deployer_address" field.
func (m *NFTClassMutation) SetDeployerAddress(s string) {
	m.deployer_address = &s
}

// DeployerAddress returns the value of the "deployer_address" field in the mutation.
func (m *NFTClassMutation) DeployerAddress() (r string, exists bool) {
	v := m.deployer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployerAddress returns the old "deployer_address" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldDeployerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployerAddress: %w", err)
	}
	return oldValue.DeployerAddress, nil
}

// ResetDeployerAddress resets all changes to the "deployer_address" field.
func (m *NFTClassMutation) ResetDeployerAddress() {
	m.deployer_address = nil
}

// SetDeployedBlockNumber sets the "deployed_block_number" field.
func (m *NFTClassMutation) SetDeployedBlockNumber(s string) {
	m.deployed_block_number = &s
}

// DeployedBlockNumber returns the value of the "deployed_block_number" field in the mutation.
func (m *NFTClassMutation) DeployedBlockNumber() (r string, exists bool) {
	v := m.deployed_block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployedBlockNumber returns the old "deployed_block_number" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldDeployedBlockNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployedBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployedBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployedBlockNumber: %w", err)
	}
	return oldValue.DeployedBlockNumber, nil
}

// ResetDeployedBlockNumber resets all changes to the "deployed_block_number" field.
func (m *NFTClassMutation) ResetDeployedBlockNumber() {
	m.deployed_block_number = nil
}

// SetMintedAt sets the "minted_at" field.
func (m *NFTClassMutation) SetMintedAt(t time.Time) {
	m.minted_at = &t
}

// MintedAt returns the value of the "minted_at" field in the mutation.
func (m *NFTClassMutation) MintedAt() (r time.Time, exists bool) {
	v := m.minted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMintedAt returns the old "minted_at" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldMintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMintedAt: %w", err)
	}
	return oldValue.MintedAt, nil
}

// ResetMintedAt resets all changes to the "minted_at" field.
func (m *NFTClassMutation) ResetMintedAt() {
	m.minted_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NFTClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NFTClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NFTClass entity.
// If the NFTClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NFTClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddNftIDs adds the "nfts" edge to the NFT entity by ids.
func (m *NFTClassMutation) AddNftIDs(ids ...int) {
	if m.nfts == nil {
		m.nfts = make(map[int]struct{})
	}
	for i := range ids {
		m.nfts[ids[i]] = struct{}{}
	}
}

// ClearNfts clears the "nfts" edge to the NFT entity.
func (m *NFTClassMutation) ClearNfts() {
	m.clearednfts = true
}

// NftsCleared reports if the "nfts" edge to the NFT entity was cleared.
func (m *NFTClassMutation) NftsCleared() bool {
	return m.clearednfts
}

// RemoveNftIDs removes the "nfts" edge to the NFT entity by IDs.
func (m *NFTClassMutation) RemoveNftIDs(ids ...int) {
	if m.removednfts == nil {
		m.removednfts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nfts, ids[i])
		m.removednfts[ids[i]] = struct{}{}
	}
}

// RemovedNfts returns the removed IDs of the "nfts" edge to the NFT entity.
func (m *NFTClassMutation) RemovedNftsIDs() (ids []int) {
	for id := range m.removednfts {
		ids = append(ids, id)
	}
	return
}

// NftsIDs returns the "nfts" edge IDs in the mutation.
func (m *NFTClassMutation) NftsIDs() (ids []int) {
	for id := range m.nfts {
		ids = append(ids, id)
	}
	return
}

// ResetNfts resets all changes to the "nfts" edge.
func (m *NFTClassMutation) ResetNfts() {
	m.nfts = nil
	m.clearednfts = false
	m.removednfts = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NFTClassMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NFTClassMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NFTClassMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NFTClassMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NFTClassMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NFTClassMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NFTClassMutation builder.
func (m *NFTClassMutation) Where(ps ...predicate.NFTClass) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NFTClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NFTClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NFTClass, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NFTClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NFTClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NFTClass).
func (m *NFTClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTClassMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.address != nil {
		fields = append(fields, nftclass.FieldAddress)
	}
	if m.name != nil {
		fields = append(fields, nftclass.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, nftclass.FieldSymbol)
	}
	if m.owner_address != nil {
		fields = append(fields, nftclass.FieldOwnerAddress)
	}
	if m.minter_addresses != nil {
		fields = append(fields, nftclass.FieldMinterAddresses)
	}
	if m.total_supply != nil {
		fields = append(fields, nftclass.FieldTotalSupply)
	}
	if m.metadata != nil {
		fields = append(fields, nftclass.FieldMetadata)
	}
	if m.banner_image != nil {
		fields = append(fields, nftclass.FieldBannerImage)
	}
	if m.featured_image != nil {
		fields = append(fields, nftclass.FieldFeaturedImage)
	}
	if m.deployer_address != nil {
		fields = append(fields, nftclass.FieldDeployerAddress)
	}
	if m.deployed_block_number != nil {
		fields = append(fields, nftclass.FieldDeployedBlockNumber)
	}
	if m.minted_at != nil {
		fields = append(fields, nftclass.FieldMintedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nftclass.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldAddress:
		return m.Address()
	case nftclass.FieldName:
		return m.Name()
	case nftclass.FieldSymbol:
		return m.Symbol()
	case nftclass.FieldOwnerAddress:
		return m.OwnerAddress()
	case nftclass.FieldMinterAddresses:
		return m.MinterAddresses()
	case nftclass.FieldTotalSupply:
		return m.TotalSupply()
	case nftclass.FieldMetadata:
		return m.Metadata()
	case nftclass.FieldBannerImage:
		return m.BannerImage()
	case nftclass.FieldFeaturedImage:
		return m.FeaturedImage()
	case nftclass.FieldDeployerAddress:
		return m.DeployerAddress()
	case nftclass.FieldDeployedBlockNumber:
		return m.DeployedBlockNumber()
	case nftclass.FieldMintedAt:
		return m.MintedAt()
	case nftclass.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nftclass.FieldAddress:
		return m.OldAddress(ctx)
	case nftclass.FieldName:
		return m.OldName(ctx)
	case nftclass.FieldSymbol:
		return m.OldSymbol(ctx)
	case nftclass.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case nftclass.FieldMinterAddresses:
		return m.OldMinterAddresses(ctx)
	case nftclass.FieldTotalSupply:
		return m.OldTotalSupply(ctx)
	case nftclass.FieldMetadata:
		return m.OldMetadata(ctx)
	case nftclass.FieldBannerImage:
		return m.OldBannerImage(ctx)
	case nftclass.FieldFeaturedImage:
		return m.OldFeaturedImage(ctx)
	case nftclass.FieldDeployerAddress:
		return m.OldDeployerAddress(ctx)
	case nftclass.FieldDeployedBlockNumber:
		return m.OldDeployedBlockNumber(ctx)
	case nftclass.FieldMintedAt:
		return m.OldMintedAt(ctx)
	case nftclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NFTClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case nftclass.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nftclass.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case nftclass.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case nftclass.FieldMinterAddresses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinterAddresses(v)
		return nil
	case nftclass.FieldTotalSupply:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSupply(v)
		return nil
	case nftclass.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case nftclass.FieldBannerImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerImage(v)
		return nil
	case nftclass.FieldFeaturedImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImage(v)
		return nil
	case nftclass.FieldDeployerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployerAddress(v)
		return nil
	case nftclass.FieldDeployedBlockNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployedBlockNumber(v)
		return nil
	case nftclass.FieldMintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMintedAt(v)
		return nil
	case nftclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTClassMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_supply != nil {
		fields = append(fields, nftclass.FieldTotalSupply)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nftclass.FieldTotalSupply:
		return m.AddedTotalSupply()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nftclass.FieldTotalSupply:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSupply(v)
		return nil
	}
	return fmt.Errorf("unknown NFTClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nftclass.FieldOwnerAddress) {
		fields = append(fields, nftclass.FieldOwnerAddress)
	}
	if m.FieldCleared(nftclass.FieldMinterAddresses) {
		fields = append(fields, nftclass.FieldMinterAddresses)
	}
	if m.FieldCleared(nftclass.FieldMetadata) {
		fields = append(fields, nftclass.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTClassMutation) ClearField(name string) error {
	switch name {
	case nftclass.FieldOwnerAddress:
		m.ClearOwnerAddress()
		return nil
	case nftclass.FieldMinterAddresses:
		m.ClearMinterAddresses()
		return nil
	case nftclass.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown NFTClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTClassMutation) ResetField(name string) error {
	switch name {
	case nftclass.FieldAddress:
		m.ResetAddress()
		return nil
	case nftclass.FieldName:
		m.ResetName()
		return nil
	case nftclass.FieldSymbol:
		m.ResetSymbol()
		return nil
	case nftclass.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case nftclass.FieldMinterAddresses:
		m.ResetMinterAddresses()
		return nil
	case nftclass.FieldTotalSupply:
		m.ResetTotalSupply()
		return nil
	case nftclass.FieldMetadata:
		m.ResetMetadata()
		return nil
	case nftclass.FieldBannerImage:
		m.ResetBannerImage()
		return nil
	case nftclass.FieldFeaturedImage:
		m.ResetFeaturedImage()
		return nil
	case nftclass.FieldDeployerAddress:
		m.ResetDeployerAddress()
		return nil
	case nftclass.FieldDeployedBlockNumber:
		m.ResetDeployedBlockNumber()
		return nil
	case nftclass.FieldMintedAt:
		m.ResetMintedAt()
		return nil
	case nftclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NFTClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nfts != nil {
		edges = append(edges, nftclass.EdgeNfts)
	}
	if m.owner != nil {
		edges = append(edges, nftclass.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.nfts))
		for id := range m.nfts {
			ids = append(ids, id)
		}
		return ids
	case nftclass.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednfts != nil {
		edges = append(edges, nftclass.EdgeNfts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nftclass.EdgeNfts:
		ids := make([]ent.Value, 0, len(m.removednfts))
		for id := range m.removednfts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednfts {
		edges = append(edges, nftclass.EdgeNfts)
	}
	if m.clearedowner {
		edges = append(edges, nftclass.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTClassMutation) EdgeCleared(name string) bool {
	switch name {
	case nftclass.EdgeNfts:
		return m.clearednfts
	case nftclass.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTClassMutation) ClearEdge(name string) error {
	switch name {
	case nftclass.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NFTClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTClassMutation) ResetEdge(name string) error {
	switch name {
	case nftclass.EdgeNfts:
		m.ResetNfts()
		return nil
	case nftclass.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown NFTClass edge %s", name)
}
